-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | code examples
--   
--   Please see the README on GitLab at
--   <a>https://github.com/frankhjung/haskell-scrapbook#readme</a>
@package scrapbook
@version 0.1.0


-- | Example rank-n-type from <a>Explaining Haskell RankNTypes for all</a>.
module ApplyToTuple

-- | Example of a rank N type. This will apply the function to the provided
--   input tuple.
--   
--   <pre>
--   &gt;&gt;&gt; applyToTuple length ("foo", [1,2,3,4])
--   (3,4)
--   </pre>
applyToTuple :: forall b c. (forall a. [a] -> Int) -> ([b], [c]) -> (Int, Int)


-- | Example implementation of <a>binary search</a>.
module BinarySearch

-- | Binary Search
--   
--   Example using an integer array, search list <tt>[1..6]</tt> for values
--   <tt>[1..8]</tt>.
--   
--   Expect <tt>1..6</tt> will return <a>Just</a> values, while <tt>7</tt>
--   and <tt>8</tt> will return <a>Nothing</a>.
--   
--   The same also applies for strings. Try "abcdef" and "gh".
bsearch :: Ord a => [a] -> a -> Maybe a


-- | Code from <a>Yet Another Haskell Tutorial</a>
module CFold

-- | CPS fold.
--   
--   <pre>
--   &gt;&gt;&gt; λ&gt; cfold' (\x t g -&gt; (x : g t)) [] [1..10]
--   [1,2,3,4,5,6,7,8,9,10]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; λ&gt; cfold' (\x t g -&gt; g (x : t)) [] [1..10]
--   [10,9,8,7,6,5,4,3,2,1]
--   </pre>
cfold' :: (t1 -> t2 -> (t2 -> t2) -> t2) -> t2 -> [t1] -> t2

-- | Wrapper function to <a>cfold</a>`.
--   
--   <pre>
--   &gt;&gt;&gt; λ&gt; cfold (+) 0 [1..3]
--   6
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; λ&gt; cfold (:) [] [1..3]
--   [1,2,3]
--   </pre>
cfold :: (t1 -> t2 -> t2) -> t2 -> [t1] -> t2


-- | Code from <a>Haskell Bookcamp</a> by Philipp Hagenlocher
--   
--   This is my version of a simplified <a>Caesar Cipher</a>.
module Caesar

-- | Simple implementation of Caesar Cipher.
caesar :: Int -> String -> String

-- | Limited ASCII character set, includes all printable characters except
--   the space character.
isAscii :: Char -> Bool

-- | Rotate a ascii character. 94 = 126 - 33 + 1 33 is starting offset of
--   printable characters (after space)
asciiRot :: Int -> Char -> Char


-- | From "Get Programming with Haskell" by Will Kurt, Lesson 17. Design by
--   composition—Semigroups and Monoids
module Colours

-- | Acceptable colours.
data Colour
Red :: Colour
Yellow :: Colour
Blue :: Colour
Green :: Colour
Purple :: Colour
Orange :: Colour
Brown :: Colour
instance GHC.Enum.Enum Colours.Colour
instance GHC.Enum.Bounded Colours.Colour
instance GHC.Classes.Eq Colours.Colour
instance GHC.Show.Show Colours.Colour
instance GHC.Base.Semigroup Colours.Colour
instance Test.QuickCheck.Arbitrary.Arbitrary Colours.Colour


-- | From <a>Chapter 18, Monad Transformers, Real World Haskell by Bryan
--   O'Sullivan, Don Stewart, and John Goerzen</a>.
--   
--   The function <a>countEntries1</a> is my version of
--   <tt>countEntriesTrad</tt> from this chapter (<a>countEntriesS</a>,
--   <tt>S</tt> means standard or traditional).
--   
--   The Monad Transformer version is <a>countEntries2</a> which is my
--   version of <tt>countEntries</tt>.
--   
--   <h2>GHCi Session</h2>
--   
--   <h3>Packages</h3>
--   
--   <pre>
--   :m + Control.Monad
--   :m + System.Directory
--   :m + System.FilePath
--   </pre>
--   
--   <h3>Resources</h3>
--   
--   This is a really good introduction to Monad Transformers, <a>Monday
--   Morning Haskell: Monad Transformers</a>.
--   
--   The functions <a>countEntriesS</a> and <a>countEntriesU</a> are based
--   off functions from <a>Chapter 18, Monad Transformers, Real World
--   Haskell by Bryan O'Sullivan, Don Stewart, and John Goerzen</a>.
module CountEntries

-- | Count entries for a list of paths. (My version.)
--   
--   <h2>Example</h2>
--   
--   What the function returns is a list of tuples of directory and count
--   of entries in that directory:
--   
--   <pre>
--   &gt;&gt;&gt; countEntries1 "public"
--   [("public",25),("public/src",16)]
--   </pre>
--   
--   <h3>Explanation</h3>
--   
--   The function composes a number of different system calls. But the
--   process is simple but clunky using traditional methods. The process
--   will be much simplified once when Monad Transformers are used in
--   <a>countEntries2</a>.
--   
--   <pre>
--   &gt;&gt;&gt; p = "public"
--   </pre>
--   
--   Get contents of path ... and filter to report directories only:
--   
--   <pre>
--   &gt;&gt;&gt; (getDirectoryContents p) &gt;&gt;= filterM (\n -&gt; doesDirectoryExist (p &lt;/&gt; n))
--   ["..","src","."]
--   </pre>
--   
--   List directory ignores current and parent directories:
--   
--   <pre>
--   &gt;&gt;&gt; listDirectory p &gt;&gt;= filterM (\n -&gt; doesDirectoryExist (p &lt;/&gt; n))
--   ["src"]
--   </pre>
--   
--   Some ways to count number of entries in the path:
--   
--   <pre>
--   &gt;&gt;&gt; ps &lt;- listDirectory p
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; length ps
--   25
--   </pre>
--   
--   Same as:
--   
--   <pre>
--   &gt;&gt;&gt; listDirectory p &gt;&gt;= return . length
--   25
--   </pre>
--   
--   Which is equivalent to:
--   
--   <pre>
--   &gt;&gt;&gt; liftM length (listDirectory p)
--   25
--   </pre>
--   
--   Recurse into subdirectories:
--   
--   <pre>
--   &gt;&gt;&gt; listDirectory p &gt;&gt;= filterM (\n -&gt; doesDirectoryExist (p &lt;/&gt; n)) &gt;&gt;= mapM_ print
--   "src"
--   </pre>
countEntries1 :: FilePath -> IO [(FilePath, Int)]

-- | Count entries in directories for given path. My version using
--   <a>WriterT</a>.
countEntries2 :: FilePath -> WriterT [(FilePath, Int)] IO ()

-- | Count entries in directories for given path. Standard version as
--   documented in Real World Haskell.
--   
--   <pre>
--   &gt;&gt;&gt; p = "public"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :t listDirectory p
--   listDirectory p :: IO [FilePath]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; countEntriesS p
--   [("public",25),("public/src",16)]
--   </pre>
countEntriesS :: FilePath -> IO [(FilePath, Int)]

-- | Count entries in directories for given path. Updated version using
--   <a>WriterT</a>.
countEntriesU :: FilePath -> WriterT [(FilePath, Int)] IO ()


-- | Example from <a>Wikibooks Continuation Passing Style</a>.
--   
--   Uses the Cont monad from the transformers package.
--   
--   Using <tt>callCC</tt> is better than using return as argument is a
--   function and it returns a suspended computation.
module Cps

-- | Continuation for add function.
addCont :: Int -> Int -> Cont r Int

-- | Continuation for pythagoras function.
pythagorasCont :: Int -> Int -> Cont r Int

-- | Continuation for square function.
squareCont :: Int -> Cont r Int


-- | Reference
--   &lt;<a>https://stackoverflow.com/questions/23616455/haskell-type-new-type-or-data-for-only-an-upper-case-char</a>
--   type for uppercase characters&gt;
module Lower

-- | Make a lowercase letter.
mkLower :: Char -> Either String Char


-- | Tests whether value a integer value is modulus 3 or modulus 5.
--   
--   <pre>
--   &gt;&gt;&gt; mod35 15
--   </pre>
module Mod35

-- | Test if modulus 3 or 5.
mod35 :: Int -> Bool


-- | Code based on <a>FPComplete Monad Transformers</a>
module MonTrans

-- | Basic implementation.
sumTillNegative :: [Int] -> Int

-- | Fold strict sum with early termination.
sumTillNegative' :: [Int] -> Int

-- | Returns either the total (left value) or the current accumulation and
--   the rest of the list. The left value will terminate the loop. See also
--   <a>either</a>
sumTillNegative'' :: [Int] -> Int


-- | Filter a list using fold. In the Prelude, <a>filter</a> is defined as
--   a recursive function:
--   
--   <pre>
--   filter :: (a -&gt; Bool) -&gt; [a] -&gt; [a]
--   filter _pred []    = []
--   filter pred (x:xs)
--     | pred x         = x : filter pred xs
--     | otherwise      = filter pred xs
--   </pre>
module MyFilter

-- | Filter a list using foldr.
myFilter :: (Foldable t, Ord a) => (a -> Bool) -> t a -> [a]


-- | Get the penultimate of a list.
module MyPenultimate

-- | Get second to last element of a list.
penultimate :: [a] -> Maybe a


-- | Reverse a list using foldl and foldr.
module MyReverse

-- | Reverse a list using foldl.
myRevl :: [a] -> [a]

-- | Reverse a list using foldr.
myRevr :: [a] -> [a]

-- | Reverse using recursion and reverse operation.
myRevr2 :: [a] -> [a]


module MyTake

-- | My version of take. This does not check for negative numbers.
--   
--   <pre>
--   &gt;&gt;&gt; myTake 1 "abc"
--   "a"
--   </pre>
myTake :: Int -> [a] -> [a]


module MyType

-- | Proxy to record type. Proxy is equivalent to the unit type,
--   <tt>()</tt>. But also has a phantom type parameter <tt>a</tt>, which
--   is used to keep track of the type. (Use type from <a>Proxy</a>) data
--   Proxy a = Proxy
--   
--   Show ambigous types. Hindley-Milner type system can only infer types
--   to the right of the context arrow (<tt>=&gt;</tt>), which means the
--   type parameter <tt>a</tt> can never be correctly inferred. Haskell
--   refers to such a type as <i>ambiguous</i>.
--   
--   <pre>
--   &gt;&gt;&gt; typeName @Int
--   "Int"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; typeName @String
--   "[Char]"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; typeName @(Maybe [Int])
--   "Maybe [Int]"
--   </pre>
typeName :: forall a. Typeable a => String


-- | From the book <a>Algorithm Design with Haskell by R. Bird and J.
--   Gibbons</a>.
module Permutation

-- | Insert character into list at each location.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; inserts 'a' "bc"
--   ["abc","bac","bca"]
--   </pre>
inserts :: a -> [a] -> [[a]]

-- | Generate permutations using list comprehensions.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; perms1 "abc"
--   ["abc","bac","bca","acb","cab","cba"]
--   </pre>
perms1 :: [a] -> [[a]]

-- | Generate permutations using list comprehensions.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; perms2 "abc"
--   ["abc","acb","bac","bca","cab","cba"]
--   </pre>
perms2 :: [a] -> [[a]]

-- | Use fold to generate permutaions.
perms3 :: [a] -> [[a]]

-- | Pick each member from list return tuple of member and items remaining.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; picks "abc"
--   [('a',"bc"),('b',"ac"),('c',"ab")]
--   </pre>
picks :: [a] -> [(a, [a])]


-- | Find poly-divisible numbers such that we use digits from 1 to 9, and
--   the first n digits are modulo n for all digits in the number.
--   
--   I first read about puzzle in Matt Parkers book, <a>Things to make and
--   do in the fourth dimension</a>.
--   
--   The poly divisors listed here are in descending order of performance.
--   i.e. <tt>isPolyMod</tt> better than <tt>isPolyMod'</tt> which is
--   better than <tt>isPolyMod''</tt>
--   
--   <h2>Method</h2>
--   
--   <ul>
--   <li>convert string input to int</li>
--   <li>permute a list of digits 1..9</li>
--   <li>filter modulo (length) for length digits</li>
--   </ul>
--   
--   <h2>Exploration</h2>
--   
--   Investigate how to use a fold instead of recursion:
--   
--   <pre>
--   &gt;&gt;&gt; x = 123456789
--   
--   &gt;&gt;&gt; n = length (show x)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; λ&gt; map (\p -&gt; x `div` 10^p ) [0..n-1]
--   [123456789,12345678,1234567,123456,12345,1234,123,12,1]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; λ&gt; f x = let n = length (show x) in x `mod` n == 0
--   
--   &gt;&gt;&gt; λ&gt; f 12
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; λ&gt; foldr (\x -&gt; (&amp;&amp;) (f x)) True xs
--   False
--   </pre>
--   
--   <h2>Examples</h2>
--   
--   Load in GHCi:
--   
--   <pre>
--   &gt;&gt;&gt; $ cabal repl
--   
--   &gt;&gt;&gt; λ&gt; :load PolyDivisors
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; λ&gt; findPolyDiv 123
--   [123,321]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; λ&gt; findPolyDiv 123456
--   [123654,321654]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; λ&gt; findPolyDiv 123456789
--   [381654729]
--   </pre>
module PolyDivisors

-- | Find poly-divisor of input string.
findPolyDiv :: Int -> [Int]

-- | <a>isPolyMod</a>: Test number is modulo <tt>n ... 1</tt>.
isPolyMod :: Int -> Bool

-- | <tt>isPolyMod''</tt>: Test number is modulo <tt>n ... 1</tt>.
isPolyMod' :: Int -> Bool

-- | <tt>isPolyMod''</tt>: Test number is modulo <tt>n ... 1</tt>.
isPolyMod'' :: Int -> Bool


-- | A simple implementation of <a>Qsort</a>.
--   
--   From "Programming in Haskell" by Graham Hutton.
--   
--   <pre>
--   &gt;&gt;&gt; qsort [3,5,1,2,4,2]
--   [1,2,2,3,4,5]
--   </pre>
--   
--   If <tt>a &lt;= x</tt> is replaced with <tt>a &lt; x</tt>, then only
--   unique values are reported.
--   
--   <pre>
--   &gt;&gt;&gt; qsort' [3,5,1,2,4,2]
--   [1,2,3,4,5]
--   </pre>
--   
--   To reverse sort, switch smaller and larger in <a>qsort</a>.
--   
--   <pre>
--   &gt;&gt;&gt; qsort'' [3,5,1,2,4,2]
--   [5,4,3,2,2,1]
--   </pre>
module Qsort

-- | A simple implementation of <a>Qsort</a>.
qsort :: (Show a, Ord a) => [a] -> [a]


-- | Exploration of the use of <a>Random</a> inspired by <a>Haskell Design
--   Patterns by Ryan Lemmer</a>
--   
--   <h2>Example</h2>
--   
--   Simulate roll a fair 6-sided dice <i>n</i> times.
--   
--   With a <a>seed</a> of <tt>111111</tt> then we expect
--   <tt>[4,6,5,3,2]</tt>.
module Random

-- | Range for a 6-sided dice.
dice :: (Int, Int)

-- | Return <i>n</i> rolls of the dice using the system random generator.
roll :: Int -> IO [Int]

-- | Produce an infinite stream of <a>dice</a> rolls.
rolls :: StdGen -> [Int]

-- | Seed the dice's random generator.
seed :: Int -> StdGen


-- | A collection of recursion scheme examples.
--   
--   <h1>Examples</h1>
--   
--   <h2>Anamorphism</h2>
--   
--   Using a non-recursive coalgebra to create a <a>ListF</a>.
--   
--   <pre>
--   test = buildListF 4
--   show test
--   "ConsF 4 (ConsF 3 (ConsF 2 (ConsF 1 NilF)))"
--   
--   λ&gt; :t unFix test
--   unFix test :: ListF Int (Fix (ListF Int))
--   
--   λ&gt; :t test
--   test :: Fix (ListF Int)
--   </pre>
--   
--   <h2>Catamorphism</h2>
--   
--   Using a non-recursive algebra to measure length of <a>ListF</a> entry,
--   use a catamorphism over the alegra to measure length of the entire
--   <a>ListF</a>.
--   
--   <pre>
--   test :: Int a =&gt; Fix (ListF a)
--   test = Fix (ConsF 4 (Fix (ConsF 3 (Fix (ConsF 2 (Fix (ConsF 1 (Fix NilF))))))))
--   
--   lengthListF test
--   4
--   </pre>
--   
--   <h2>Paramorphism</h2>
--   
--   The paramorphism examples come from "Making Sense of Recursion
--   Patterns". A paramorphism is like a catamorphism, but it preserves the
--   initial data structure.
--   
--   <h1>References</h1>
--   
--   <ul>
--   <li><a>Deriving a functor for an infinite stream</a></li>
--   <li><a>Making Sense of Recursion Patterns by Paul Bailes and Leighton
--   Brough</a></li>
--   </ul>
module RecursionSchemes

-- | Generalised fixed point for any functor <i>f</i>. Note that <tt>unFix
--   (Fix x) == x</tt>
newtype Fix f
Fix :: f (Fix f) -> Fix f
[unFix] :: Fix f -> f (Fix f)

-- | List Functor where r is the carrier type.
data ListF a r
NilF :: ListF a r
ConsF :: a -> r -> ListF a r

-- | Natural numbers Functor.
data NatF r
ZeroF :: NatF r
SuccF :: r -> NatF r

-- | Natural numbers type.
type Nat = Fix NatF

-- | R-Algebra
type RAlgebra f a = Fix f -> f a -> a

-- | Anamorphism - produce a structure.
ana :: Functor f => (a -> f a) -> a -> Fix f

-- | Catamorphism - consume a structure.
cata :: Functor f => (f a -> a) -> Fix f -> a

-- | Paramorphism - improved consumption of a structure.
para :: Functor f => RAlgebra f a -> Fix f -> a

-- | Paramorphism where input list is the first parameter. This comes from
--   <a>Making Sense of Recursion Patterns</a> by Paul Bailes and Leighton
--   Brough. It extends <a>foldr</a> by supplying to the combining
--   operation (op) the unprocessed list tail, in addition to the head and
--   the result of recursion on the tail as provided by <a>foldr</a>.
--   
--   Sum a list:
--   
--   <pre>
--   &gt;&gt;&gt; para' (const . (+)) 0 [1,2,3]
--   6
--   </pre>
--   
--   Suffixes of a list:
--   
--   <pre>
--   &gt;&gt;&gt; para' (const (:)) [] "abcd"
--   ["bcd","cd","d",""]
--   </pre>
para' :: (a -> [a] -> b -> b) -> b -> [a] -> b

-- | Paramorphism using <a>foldr</a>. This comes from <a>Making Sense of
--   Recursion Patterns</a> by Paul Bailes and Leighton Brough.
--   
--   The following shows how to get a catamorphism from a paramorphism. In
--   this example, we are calculating the sum of items from a list.
--   
--   Sum a list:
--   
--   <pre>
--   &gt;&gt;&gt; para'' (const . (+)) 0 [1,2,3]
--   6
--   </pre>
--   
--   Suffixes of a list:
--   
--   <pre>
--   &gt;&gt;&gt; para'' (\ _ xs xss -&gt; xs : xss) [] "abcd"
--   ["bcd","cd","d",""]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; para'' (const (:)) [] "abcd"
--   ["bcd","cd","d",""]
--   </pre>
para'' :: (a -> [a] -> b -> b) -> b -> [a] -> b

-- | Feed coalgebra to anamorphism. This will build a list.
--   
--   <pre>
--   &gt;&gt;&gt; buildListF 4 :: Fix (ListF Int)
--   ConsF 4 (ConsF 3 (ConsF 2 (ConsF 1 NilF)))
--   </pre>
buildListF :: Int -> Fix (ListF Int)

-- | Coalgebra is a non-recursive function to generate a <a>ListF</a>
--   entry.
buildCoalg :: Int -> ListF Int Int

-- | An alegbra over <a>ListF</a> to get list length.
lengthAlg :: ListF a Int -> Int

-- | Length is a folding operation, i.e. a Catamorphism.
--   
--   <pre>
--   &gt;&gt;&gt; (lengthListF . buildListF) 4
--   4
--   </pre>
lengthListF :: Fix (ListF a) -> Int

-- | Length using special case of paramorphism.
--   
--   <pre>
--   &gt;&gt;&gt; lengthListF' (buildListF 4)
--   4
--   </pre>
lengthListF' :: Fix (ListF a) -> Int

-- | Convert Natural number to an integer.
--   
--   <pre>
--   &gt;&gt;&gt; fromNat (toNat 4)
--   4
--   </pre>
fromNat :: Nat -> Int

-- | Build a natural number from an interger.
--   
--   <pre>
--   &gt;&gt;&gt; toNat 4
--   SuccF (SuccF (SuccF (SuccF ZeroF)))
--   </pre>
toNat :: Int -> Nat

-- | Insert element into list at correct ordered position using
--   <a>foldr</a>.
--   
--   <pre>
--   &gt;&gt;&gt; insert 1 [2,3,4]
--   [1,2,3,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; insert 'c' "abde"
--   "abcde"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; insert 'f' "abcde"
--   "abcdef"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; insert 'o' "oa"
--   "ooa"
--   </pre>
insert :: Ord a => a -> [a] -> [a]

-- | Insert element into list at correct ordered position.
--   
--   <pre>
--   &gt;&gt;&gt; insert' 1 [2,3,4]
--   [1,2,3,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; insert' 1 []
--   [1]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; insert' 'c' "abde"
--   "abcde"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; insert' 'c' "abde" == "abcde"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; insert' 'o' "oa"
--   "ooa"
--   </pre>
insert' :: Ord a => a -> [a] -> [a]

-- | Convert a <a>ListF</a> to a standard list.
toList :: Fix (ListF a) -> [a]

-- | Indexing a list.
--   
--   <pre>
--   &gt;&gt;&gt; idx0 "abcde"
--   [0,1,2,3,4]
--   </pre>
idx0 :: (Foldable t, Num b) => t a -> [b]

-- | Alternate list indexing using <a>foldr</a>.
--   
--   <pre>
--   &gt;&gt;&gt; idx1 "abcde"
--   [0,1,2,3,4]
--   </pre>
idx1 :: (Foldable t, Num b) => t a -> [b]

-- | Alternate list indexing using <a>zipWith</a>.
--   
--   <pre>
--   &gt;&gt;&gt; idx2 "abcde"
--   [0,1,2,3,4]
--   </pre>
idx2 :: [b] -> [Integer]

-- | List indexing using <a>foldr</a>.
--   
--   <pre>
--   &gt;&gt;&gt; idx3 "abcde"
--   [0,1,2,3,4]
--   </pre>
idx3 :: Foldable t => t a -> [Integer]

-- | List indexing using <a>foldr</a> with parameter last.
--   
--   <pre>
--   &gt;&gt;&gt; idx4 "abcde"
--   [0,1,2,3,4]
--   </pre>
idx4 :: [b] -> [Integer]
instance (GHC.Classes.Eq a, GHC.Classes.Eq r) => GHC.Classes.Eq (RecursionSchemes.ListF a r)
instance (GHC.Show.Show a, GHC.Show.Show r) => GHC.Show.Show (RecursionSchemes.ListF a r)
instance GHC.Base.Functor (RecursionSchemes.ListF a)
instance GHC.Base.Functor RecursionSchemes.NatF
instance GHC.Show.Show r => GHC.Show.Show (RecursionSchemes.NatF r)
instance GHC.Show.Show (f (RecursionSchemes.Fix f)) => GHC.Show.Show (RecursionSchemes.Fix f)
instance GHC.Classes.Eq (f (RecursionSchemes.Fix f)) => GHC.Classes.Eq (RecursionSchemes.Fix f)


-- | From <a>Time Traveling In Haskell: How It Works And How To Use It</a>
--   by Daniel Lafe.
--   
--   Code for what Csongor calls the repMax problem:
--   
--   <pre>
--   Imagine you had a list, and you wanted to replace all the elements of
--   the list with the largest element, by only passing the list once.
--   </pre>
--   
--   How can we possibly do this in one pass? First, we need to find the
--   maximum element, and only then can we have something to replace the
--   other numbers with! It turns out, though, that we can just expect to
--   have the future value, and all will be well.
--   
--   In the function <a>repMax</a> takes the list of integers, each of
--   which it must replace with their maximum element. It also takes as an
--   argument the maximum element, as if it had already been computed. It
--   does, however, still compute the intermediate maximum element, in the
--   form of <tt>m'</tt>. Otherwise, where would the future value even come
--   from?
--   
--   Thus far, nothing too magical has happened. It’s a little strange to
--   expect the result of the computation to be given to us; it just looks
--   like wishful thinking. The real magic happens in Csongor’s
--   <a>doRepMax</a> function.
--   
--   Look, in particular, on the line with the <tt>where</tt> clause. We
--   see that <a>repMax</a> returns the maximum element of the list,
--   largest, and the resulting list <tt>xs'</tt> consisting only of
--   <i>largest</i> repeated as many times as <tt>xs</tt> had elements. But
--   what’s curious is the call to <a>repMax</a> itself. It takes as input
--   <tt>xs</tt>, the list we’re supposed to process and largest, the value
--   that <i>it itself returns</i>.
--   
--   See also <a>Time travel in Haskell for dummies</a> by Csongor Kiss.
--   
--   See <a>this</a> for an explanation on how <a>mapAccumR</a> works.
--   
--   <h2>Example</h2>
--   
--   Run <a>doRepMax</a> or <a>foldMax</a> over some lists:
--   
--   <pre>
--   &gt;&gt;&gt; doRepMax [2,3,1,4,5]
--   [5,5,5,5,5]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; doRepMax [-2,-3,-1,-4,-5]
--   [-1,-1,-1,-1,-1]
--   </pre>
module RepMax

-- | Replace list with maximum value in the list.
doRepMax :: Integral a => [a] -> [a]

-- | Fold version of <a>repMax</a>.
--   
--   Modified to also work with negative values. <i>"Everything's a
--   fold".</i>
foldMax :: Integral a => [a] -> [a]

-- | Repeat given maximum for entire list.
repMax :: Integral a => [a] -> a -> (a, [a])

-- | Generalise <a>repMax</a> where input is a <tt>Traversable</tt>.
--   
--   Seed value from <tt>First</tt> of <tt>Foldable</tt>.
traverseMax :: (Traversable t, Integral a) => t a -> t a

-- | Generalise <a>repMax</a> where input is a <tt>Traversable</tt>.
--   
--   Seed maximum value from head of list or 0 if empty.
traverseMax' :: (Traversable t, Integral a) => t a -> t a


-- | Split a list in half using <a>zipWith</a>.
--   
--   From <a>My favorite Haskell function by David Luposchainsky</a>
module SplitList

-- | Drop every second element.
every2nd :: [a] -> [a]

-- | Ignore count of first elements then print overflow from second.
zipOverflow :: [a] -> [a] -> [a]

-- | Split list into two.
splitMiddle :: [a] -> ([a], [a])


-- | A simple State monad implementation to explore it's characteristics.
--   
--   Based on many articles, but principally from: <a>The State Monad: A
--   Tutorial for the Confused?</a>
module State

-- | Mock of State data type. (Not yet a Monad, Functor or Applicative.)
newtype State s a
State :: (s -> (a, s)) -> State s a
[runState] :: State s a -> s -> (a, s)

-- | Returns current state.
get :: State s s

-- | Replace current state with the given value. Returns unit.
put :: s -> State s ()

-- | Update current state using the given function.
modify :: (s -> s) -> State s ()

-- | Returns results of state function.
evalState :: State s a -> s -> a

-- | Returns final state.
execState :: State s a -> s -> s
instance GHC.Base.Functor (State.State s)
instance GHC.Base.Applicative (State.State s)
instance GHC.Base.Monad (State.State s)


-- | Use the <a>State</a> monad to implement a <a>Stack</a>.
--   
--   Source: <a>sdiehl/state.hs</a>
module Stack

-- | Stack as array of intergers.
type Stack = [Int]

-- | Empty stack.
empty :: Stack

-- | Remove element from top of stack.
pop :: State Stack Int

-- | Push element onto stack.
push :: Int -> State Stack ()

-- | Return element at top of stack.
top :: State Stack Int

-- | Example usage of <a>State</a> <a>Stack</a>. <a>push</a> &amp;
--   <a>pop</a> some elements onto the stack, and read the current
--   <a>top</a> element.
tasks :: State Stack Int


-- | This is a collection of different ways (with different performance) to
--   create <a>subsquences</a>.
--   
--   <h1>Examples</h1>
--   
--   <pre>
--   subSeqs1 "abc" should be ["a","ab","abc","ac","b","bc","c"]
--   subSeqs2 "abc" should be ["a","ab","abc","ac","b","bc","c"]
--   subSeqs3 "abc" should be ["abc","ab","ac","a","bc","b","c",""]
--   subSeqs4 "abc" should be ["abc","ab","ac","a","bc","b","c",""]
--   </pre>
module SubSeqs

-- | From Pearls of Functional Algorithm Design.
subSeqs1 :: [a] -> [[a]]

-- | Alternative definition using just <a>foldr</a> and <a>map</a>. For
--   non-empty lists only.
subSeqs2 :: [a] -> [[a]]

-- | Using list comprehension.
subSeqs3 :: [a] -> [[a]]

-- | Create a power-set using <a>Monad</a>.
--   
--   <a>This blog</a> explains <a>filterM</a>.
subSeqs4 :: [a] -> [[a]]


-- | An inefficient alternative to <a>dropWhile</a>.
--   
--   <h1>Examples</h1>
--   
--   <pre>
--   &gt;&gt;&gt; trim " hello world "
--   "hello world"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; dropWhile' isSpace " hello world "
--   "hello word "
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; dropWhileEnd' isSpace " hello world "
--   " hello word"
--   </pre>
module Trim

-- | Drop from beginning of list while predicate is true.
dropWhile' :: (a -> Bool) -> [a] -> [a]

-- | Drop from end of list while predicate is true.
dropWhileEnd' :: (a -> Bool) -> [a] -> [a]

-- | Trim white space from start of string.
trimStart :: String -> String

-- | Trim white space from end of string.
trimEnd :: String -> String

-- | Trim white space from start and end of string.
trim :: String -> String


-- | A simple demonstration on how to map to and from a bounded, enumerated
--   data type.
--   
--   In this example we use the weekdays names as our type to iterate
--   across.
--   
--   <ul>
--   <li><a>makeWeekday</a> is a simple conversion function to map a
--   <a>Weekday</a> from a string</li>
--   <li><a>fullWeek</a> returns a list of all abbreviated weekdays</li>
--   <li><a>capitalise</a> returns the title case of a string</li>
--   </ul>
--   
--   The <a>makeWeekday</a> code is rather weak as any word where the first
--   3 letters map to a weekday is valid for conversion.
--   
--   <h2>Other Examples</h2>
--   
--   <h3>Using enum:</h3>
--   
--   This example shows how use <a>Weekday</a> from an enumeration:
--   
--   <pre>
--   &gt;&gt;&gt; toEnum 0 :: WeekDay
--   Mon
--   </pre>
module Weekday

-- | Abbreviated days of the week from Mon (Monday) to Sun (Sunday).
data Weekday
Mon :: Weekday
Tue :: Weekday
Wed :: Weekday
Thu :: Weekday
Fri :: Weekday
Sat :: Weekday
Sun :: Weekday

-- | Read a <a>Weekday</a> from a String.
--   
--   Some string to <a>Weekday</a> examples:
--   
--   <pre>
--   &gt;&gt;&gt; makeWeekday "tHU"
--   Just Thu
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; makeWeekday "sun"
--   Just Sun
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; makeWeekday "Bad"
--   Nothing
--   </pre>
--   
--   Any string bigger than 3 characters also fails: &gt;&gt;&gt;
--   makeWeekday <a>Mond</a> Nothing
makeWeekday :: String -> Maybe Weekday

-- | List all days of the week.
--   
--   <pre>
--   &gt;&gt;&gt; fullWeek
--   [Mon,Tue,Wed,Thu,Fri,Sat,Sun]
--   </pre>
fullWeek :: [Weekday]

-- | Return title case of string.
--   
--   <pre>
--   &gt;&gt;&gt; capitalise "monday"
--   "Monday"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; null (capitalise "")
--   True
--   </pre>
capitalise :: String -> String
instance GHC.Read.Read Weekday.Weekday
instance GHC.Enum.Bounded Weekday.Weekday
instance GHC.Show.Show Weekday.Weekday
instance GHC.Enum.Enum Weekday.Weekday
instance GHC.Classes.Eq Weekday.Weekday
instance Test.QuickCheck.Arbitrary.Arbitrary Weekday.Weekday


-- | Yahtzee test suite from blog <a>Good Design and Type Safety in
--   Yahtzee</a>
module Yahtzee

-- | Keep the dice, or re-roll?
data DiceChoice
Keep :: Word -> DiceChoice
Reroll :: DiceChoice

-- | Dice values from 1 to 6.
type DiceVals = [Word]

-- | Generate all rolls from a given state.
allRolls :: [DiceChoice] -> [DiceVals]


-- | From <a>Zipping with Folds</a> which is based on <a>How to Zip with
--   Folds</a>.
--   
--   The <tt>Prelude</tt>s version of <a>zip</a> uses recursion:
--   
--   <pre>
--   zip :: [a] -&gt; [b] -&gt; [(a,b)]
--   zip []     _bs    = []
--   zip _as    []     = []
--   zip (a:as) (b:bs) = (a,b) : zip as bs
--   </pre>
--   
--   But, this won't work for streams. The version included below
--   <i>does</i> work with streams. It uses a recursive type to represent
--   the stream data. This matches from the beginning of the stream. You
--   could match from the end of the stream by swapping <a>foldr</a> with
--   <a>foldl</a>.
module ZipFold

-- | Defines a recursive type.
newtype Zip a b
Zip :: (a -> (Zip a b -> b) -> b) -> Zip a b
[runZip] :: Zip a b -> a -> (Zip a b -> b) -> b

-- | Function to fuse two folds.
zip :: [a] -> [b] -> [(a, b)]

-- | Zip from fold.
--   
--   <pre>
--   &gt;&gt;&gt; zip' [1,2,3] [4,5,6]
--   [(1,4),(2,5),(3,6)]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; zip' "abc" []
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; zip' [] "abc"
--   []
--   </pre>
zip' :: [a] -> [b] -> [(a, b)]
