-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | code examples
--   
--   Please see the README on GitLab at
--   <a>https://github.com/frankhjung/haskell-scrapbook#readme</a>
@package Scrapbook
@version 0.3.3


-- | Example rank-n-type from <a>Explaining Haskell RankNTypes for all</a>.
module ApplyToTuple

-- | Example of a rank N type. This will apply the function to the provided
--   input tuple.
--   
--   <pre>
--   &gt;&gt;&gt; applyToTuple length ("foo", [1,2,3,4])
--   (3,4)
--   </pre>
applyToTuple :: forall b c. (forall a. [a] -> Int) -> ([b], [c]) -> (Int, Int)


-- | Example implementation of <a>binary search</a>.
module BinarySearch

-- | Binary Search
--   
--   Example using an integer array, search list <tt>[1..6]</tt> for values
--   <tt>[1..8]</tt>.
--   
--   Expect <tt>1..6</tt> will return <a>Just</a> values, while <tt>7</tt>
--   and <tt>8</tt> will return <a>Nothing</a>.
--   
--   The same also applies for strings. Try "abcdef" and "gh".
bsearch :: Ord a => [a] -> a -> Maybe a


-- | Code from <a>Yet Another Haskell Tutorial</a>
module CFold

-- | CPS fold.
--   
--   <pre>
--   &gt;&gt;&gt; λ&gt; cfold' (\x t g -&gt; (x : g t)) [] [1..10]
--   [1,2,3,4,5,6,7,8,9,10]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; λ&gt; cfold' (\x t g -&gt; g (x : t)) [] [1..10]
--   [10,9,8,7,6,5,4,3,2,1]
--   </pre>
cfold' :: (t1 -> t2 -> (t2 -> t2) -> t2) -> t2 -> [t1] -> t2

-- | Wrapper function to <a>cfold'</a>.
--   
--   <pre>
--   &gt;&gt;&gt; λ&gt; cfold (+) 0 [1..3]
--   6
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; λ&gt; cfold (:) [] [1..3]
--   [1,2,3]
--   </pre>
cfold :: (t1 -> t2 -> t2) -> t2 -> [t1] -> t2


-- | Code from <a>Haskell Bookcamp</a> by Philipp Hagenlocher
--   
--   This is my version of a simplified <a>Caesar Cipher</a>.
module Caesar

-- | Simple implementation of Caesar Cipher.
caesar :: Int -> String -> String

-- | Limited ASCII character set, includes all printable characters except
--   the space character.
isAscii :: Char -> Bool

-- | Rotate a ascii character. 94 = 126 - 33 + 1 33 is starting offset of
--   printable characters (after space)
asciiRot :: Int -> Char -> Char


-- | From "Get Programming with Haskell" by Will Kurt, Lesson 17. Design by
--   composition—Semigroups and Monoids
module Colours

-- | Acceptable colours.
data Colour
Red :: Colour
Yellow :: Colour
Blue :: Colour
Green :: Colour
Purple :: Colour
Orange :: Colour
Brown :: Colour
instance GHC.Enum.Enum Colours.Colour
instance GHC.Enum.Bounded Colours.Colour
instance GHC.Classes.Eq Colours.Colour
instance GHC.Show.Show Colours.Colour
instance GHC.Base.Semigroup Colours.Colour
instance Test.QuickCheck.Arbitrary.Arbitrary Colours.Colour


-- | Function variations of counting directory entries from <a>Chapter 18,
--   Monad Transformers, Real World Haskell by Bryan O'Sullivan, Don
--   Stewart, and John Goerzen</a>. The original version in the book is
--   <tt>countEntriesTrad</tt> which here is called <a>countEntries0</a>.
--   
--   The Monad Transformer version which in the book is
--   <tt>countEntries</tt> is <a>countEntries2</a> in this code.
--   
--   The other versions <a>countEntries1</a> and <a>countEntries3</a> are
--   my variations of this code.
--   
--   <h2>GHCi Session</h2>
--   
--   To test these functions in GHCi you need the following packages:
--   
--   <pre>
--   :m + Control.Monad
--   :m + System.Directory
--   :m + System.FilePath
--   </pre>
--   
--   <h3>Resources</h3>
--   
--   This is a really good introduction to Monad Transformers, <a>Monday
--   Morning Haskell: Monad Transformers</a>.
module CountEntries

-- | Count entries in directories for given path.
--   
--   This is the standard version from "Real World Haskell".
--   
--   <pre>
--   &gt;&gt;&gt; p = "public"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :t listDirectory p
--   listDirectory p :: IO [FilePath]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; countEntries0 p
--   [("public",25),("public/src",16)]
--   </pre>
countEntries0 :: FilePath -> IO [(FilePath, Int)]

-- | Count entries for a list of paths. (My version.)
--   
--   <h2>Example</h2>
--   
--   What the function returns is a list of tuples of directory and count
--   of entries in that directory:
--   
--   <pre>
--   &gt;&gt;&gt; countEntries1 "public"
--   [("public",25),("public/src",16)]
--   </pre>
--   
--   <h3>Explanation</h3>
--   
--   The function composes a number of different system calls. But the
--   process is simple but clunky using traditional methods. The process
--   will be much simplified once when Monad Transformers are used in
--   <a>countEntries2</a>.
--   
--   <pre>
--   &gt;&gt;&gt; p = "public"
--   </pre>
--   
--   Get contents of path ... and filter to report directories only:
--   
--   <pre>
--   &gt;&gt;&gt; (getDirectoryContents p) &gt;&gt;= filterM (\n -&gt; doesDirectoryExist (p &lt;/&gt; n))
--   ["..","src","."]
--   </pre>
--   
--   List directory ignores current and parent directories:
--   
--   <pre>
--   &gt;&gt;&gt; listDirectory p &gt;&gt;= filterM (\n -&gt; doesDirectoryExist (p &lt;/&gt; n))
--   ["src"]
--   </pre>
--   
--   Some ways to count number of entries in the path:
--   
--   <pre>
--   &gt;&gt;&gt; ps &lt;- listDirectory p
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; length ps
--   25
--   </pre>
--   
--   Same as:
--   
--   <pre>
--   &gt;&gt;&gt; listDirectory p &gt;&gt;= return . length
--   25
--   </pre>
--   
--   Which is equivalent to:
--   
--   <pre>
--   &gt;&gt;&gt; liftM length (listDirectory p)
--   25
--   </pre>
--   
--   Recurse into subdirectories:
--   
--   <pre>
--   &gt;&gt;&gt; listDirectory p &gt;&gt;= filterM (\n -&gt; doesDirectoryExist (p &lt;/&gt; n)) &gt;&gt;= mapM_ print
--   "src"
--   </pre>
countEntries1 :: FilePath -> IO [(FilePath, Int)]

-- | My updated version to count entries in directories for given path.
--   
--   This updated version of <a>countEntries1</a> uses <a>WriterT</a>.
countEntries2 :: FilePath -> IO [(FilePath, Int)]

-- | Count entries in directories for given path.
--   
--   My version using <a>WriterT</a>.
--   
--   This function takes a <a>FilePath</a> argument and returns an IO
--   action that, when executed, returns a list of <tt>(FilePath, Int)</tt>
--   pairs representing the number of entries in each directory.
--   
--   The implementation of <a>countEntries3</a> uses the <a>execWriterT</a>
--   function from the <a>Writer</a> module to extract the final value of
--   the writer monad and discard the log. The writer monad is used to
--   accumulate a list of <tt>(FilePath, Int)</tt> pairs representing the
--   number of entries in each directory.
--   
--   The <a>countEntries3</a> function is defined in terms of a helper
--   function <tt>go</tt> that uses WriterT to accumulate the log of
--   <tt>(FilePath, Int)</tt> pairs. The <tt>go</tt> function first uses
--   <a>listDirectory</a> to get the contents of the directory specified by
--   the <a>FilePath</a> argument. It then uses <a>tell</a> to add a tuple
--   of the directory path and the number of entries in the directory to
--   the log. Next, it uses <a>filterM</a> and <a>doesDirectoryExist</a> to
--   get a list of sub-directories in the directory. Finally, it uses
--   <a>mapM_</a> to recurse into each sub-directory and accumulate the
--   log.
--   
--   The <a>countEntries3</a> function is defined using function
--   composition, where <tt>go</tt> is composed with <a>execWriterT</a>
--   using the <tt>.</tt> operator. This creates a new function that first
--   applies <tt>go</tt> to its input, and then applies <a>execWriterT</a>
--   to the output of <tt>go</tt>.
countEntries3 :: FilePath -> IO [(FilePath, Int)]


-- | Example from <a>Wikibooks Continuation Passing Style</a>
--   
--   This uses the <a>Cont</a> Monad from the <a>transformers</a> package.
--   
--   Using <a>callCC</a> is better than using return as argument is a
--   function and it returns a suspended computation.
--   
--   A function of type <tt>a -&gt; b</tt> would become <tt>a -&gt; (b
--   -&gt; r) -&gt; r</tt> in CPS, where <tt>b -&gt; r</tt> is the
--   continuation.
module Cps

-- | Type CPS for Continuation-passing style.
--   
--   See CpsSpec.hs for usage.
newtype CPS a
CPS :: (forall r. (a -> r) -> r) -> CPS a
[runCPS] :: CPS a -> forall r. (a -> r) -> r

-- | Custom continuation passing style.
--   
--   The following example uses a custom continuation-passing style (CPS)
--   to demonstrate the general concept.
--   
--   This converts any value into a suspended computation.
--   
--   <pre>
--   flip ($) :: b -&gt; (b -&gt; c) -&gt; c
--   </pre>
--   
--   Longhand this is: <tt> toCPS a = k -&gt; k a </tt>
--   
--   Or more simply as: <tt> toCPS a k = k a </tt>
toCPS :: a -> forall r. (a -> r) -> r

-- | From custom continuation.
--   
--   The following example calls the continuation function with <a>id</a>.
--   
--   Passing <a>id</a> to the continuation function will return the value.
--   
--   <pre>
--   ($ id) :: ((a -&gt; a) -&gt; b) -&gt; b
--   </pre>
--   
--   Longhand this is: <tt> fromCPS f = f id </tt>
fromCPS :: (forall r. (a -> r) -> r) -> a

-- | Continuation passing style (CPS) examples.
--   
--   The following uses the <a>Cont</a> Monad from the
--   <tt>transformers</tt> package.
--   
--   Continuation for add function.
addCont :: Int -> Int -> Cont r Int
addOne :: Int -> Int

-- | Continuation for pythagoras function.
pythagorasCont :: Int -> Int -> Cont r Int

-- | Return version, timestamp and OS as pyramid of doom.
releaseString :: String

-- | Return version, timestamp and OS using the <a>CPS</a> type.
releaseStringCPS :: String

-- | Continuation for square function.
squareCont :: Int -> Cont r Int

-- | Returns (fixed) OS.
withOS :: (String -> r) -> r

-- | Returns (fixed) timestamp.
withTimestamp :: (Int -> r) -> r

-- | Returns (fixed) version.
withVersionNumber :: (Double -> r) -> r
instance GHC.Base.Functor Cps.CPS
instance GHC.Base.Applicative Cps.CPS
instance GHC.Base.Monad Cps.CPS


-- | Generalized Algebraic Datatypes example from <a>Datatype-Generic
--   Programming</a>.
module Expr
data Expr a
[Num] :: Int -> Expr Int
[Plus] :: Expr Int -> Expr Int -> Expr Int
[Eq] :: Expr Int -> Expr Int -> Expr Bool
[If] :: Expr Bool -> Expr e -> Expr e -> Expr e
eval :: Expr e -> e


-- | Reference
--   &lt;<a>https://stackoverflow.com/questions/23616455/haskell-type-new-type-or-data-for-only-an-upper-case-char</a>
--   type for uppercase characters&gt;
module Lower

-- | Make a lowercase letter.
mkLower :: Char -> Either String Char


-- | Tests whether value a integer value is modulus 3 or modulus 5.
--   
--   <pre>
--   &gt;&gt;&gt; mod35 15
--   </pre>
module Mod35

-- | Test if modulus 3 or 5.
mod35 :: Int -> Bool


-- | Code based on <a>FPComplete Monad Transformers</a>
module MonTrans

-- | Basic implementation.
sumTillNegative :: [Int] -> Int

-- | Fold strict sum with early termination.
sumTillNegative' :: [Int] -> Int

-- | Returns either the total (left value) or the current accumulation and
--   the rest of the list. The left value will terminate the loop. See also
--   <a>either</a>
sumTillNegative'' :: [Int] -> Int


-- | Filter a list using fold. In the Prelude, <a>filter</a> is defined as
--   a recursive function:
--   
--   <pre>
--   filter :: (a -&gt; Bool) -&gt; [a] -&gt; [a]
--   filter _pred []    = []
--   filter pred (x:xs)
--     | pred x         = x : filter pred xs
--     | otherwise      = filter pred xs
--   </pre>
module MyFilter

-- | Filter a list using foldr.
myFilter :: (Foldable t, Ord a) => (a -> Bool) -> t a -> [a]


-- | The code was originally provided by ChatGPT. It had to be modified to
--   compile. I added tests.
module MyFreeMonad

-- | Arithmetic free monad.
type ArithM = Free ArithF

-- | Arithmetic functor.
data ArithF x
Add :: Int -> x -> ArithF x
Sub :: Int -> x -> ArithF x
Mul :: Int -> x -> ArithF x
Div :: Int -> x -> ArithF x
addM :: Int -> ArithM ()
subM :: Int -> ArithM ()
mulM :: Int -> ArithM ()
divM :: Int -> ArithM ()

-- | Given Arithmetic free monad, return its value.
evalArith :: Free ArithF Int -> Int

-- | A simple example on how to use DSL:
--   
--   <pre>
--   example 0 = ((((0+10)*2)-10)/2) == 5
--   </pre>
--   
--   Get back the integer value with:
--   
--   <pre>
--   evalArith (example 0)
--   </pre>
example :: Int -> ArithM Int

-- | Another example on how to use this DSL:
example' :: Int -> ArithM Int
instance GHC.Base.Functor MyFreeMonad.ArithF
instance GHC.Show.Show x => GHC.Show.Show (MyFreeMonad.ArithF x)


-- | Decode JSON which contains special characters like <tt>°</tt> (ASCII
--   decimal 176).
--   
--   See also <a>app/Json.hs</a> for an example of how to parse JSON when
--   the first key is variable. This is common in APIs such as the Alpha
--   Vantage weekly stock prices. In that case, the first key is the date
--   of that weeks summary data.
--   
--   <h2>References</h2>
--   
--   I found this a good guide when dealing with JSON and special
--   characters:
--   <a>https://guide.aelve.com/haskell/aeson-cookbook-amra6lk6</a>
module MyJson

-- | Define a test data type.
data MyJson
MyJson :: Text -> Int -> Float -> !UTCTime -> [Int] -> MyJson
[name] :: MyJson -> Text
[identifier] :: MyJson -> Int
[modifier] :: MyJson -> Float
[created] :: MyJson -> !UTCTime
[series] :: MyJson -> [Int]

-- | A type that can be converted from JSON, with the possibility of
--   failure.
--   
--   In many cases, you can get the compiler to generate parsing code for
--   you (see below). To begin, let's cover writing an instance by hand.
--   
--   There are various reasons a conversion could fail. For example, an
--   <a>Object</a> could be missing a required key, an <a>Array</a> could
--   be of the wrong size, or a value could be of an incompatible type.
--   
--   The basic ways to signal a failed conversion are as follows:
--   
--   <ul>
--   <li><a>fail</a> yields a custom error message: it is the recommended
--   way of reporting a failure;</li>
--   <li><a>empty</a> (or <a>mzero</a>) is uninformative: use it when the
--   error is meant to be caught by some <tt>(<a>&lt;|&gt;</a>)</tt>;</li>
--   <li><a>typeMismatch</a> can be used to report a failure when the
--   encountered value is not of the expected JSON type; <a>unexpected</a>
--   is an appropriate alternative when more than one type may be expected,
--   or to keep the expected type implicit.</li>
--   </ul>
--   
--   <a>prependFailure</a> (or <a>modifyFailure</a>) add more information
--   to a parser's error messages.
--   
--   An example type and instance using <a>typeMismatch</a> and
--   <a>prependFailure</a>:
--   
--   <pre>
--   -- Allow ourselves to write <a>Text</a> literals.
--   {-# LANGUAGE OverloadedStrings #-}
--   
--   data Coord = Coord { x :: Double, y :: Double }
--   
--   instance <a>FromJSON</a> Coord where
--       <a>parseJSON</a> (<a>Object</a> v) = Coord
--           <a>&lt;$&gt;</a> v <a>.:</a> "x"
--           <a>&lt;*&gt;</a> v <a>.:</a> "y"
--   
--       -- We do not expect a non-<a>Object</a> value here.
--       -- We could use <a>empty</a> to fail, but <a>typeMismatch</a>
--       -- gives a much more informative error message.
--       <a>parseJSON</a> invalid    =
--           <a>prependFailure</a> "parsing Coord failed, "
--               (<a>typeMismatch</a> "Object" invalid)
--   </pre>
--   
--   For this common case of only being concerned with a single type of
--   JSON value, the functions <a>withObject</a>, <a>withScientific</a>,
--   etc. are provided. Their use is to be preferred when possible, since
--   they are more terse. Using <a>withObject</a>, we can rewrite the above
--   instance (assuming the same language extension and data type) as:
--   
--   <pre>
--   instance <a>FromJSON</a> Coord where
--       <a>parseJSON</a> = <a>withObject</a> "Coord" $ \v -&gt; Coord
--           <a>&lt;$&gt;</a> v <a>.:</a> "x"
--           <a>&lt;*&gt;</a> v <a>.:</a> "y"
--   </pre>
--   
--   Instead of manually writing your <a>FromJSON</a> instance, there are
--   two options to do it automatically:
--   
--   <ul>
--   <li><a>Data.Aeson.TH</a> provides Template Haskell functions which
--   will derive an instance at compile time. The generated instance is
--   optimized for your type so it will probably be more efficient than the
--   following option.</li>
--   <li>The compiler can provide a default generic implementation for
--   <a>parseJSON</a>.</li>
--   </ul>
--   
--   To use the second, simply add a <tt>deriving <a>Generic</a></tt>
--   clause to your datatype and declare a <a>FromJSON</a> instance for
--   your datatype without giving a definition for <a>parseJSON</a>.
--   
--   For example, the previous example can be simplified to just:
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric #-}
--   
--   import <a>GHC.Generics</a>
--   
--   data Coord = Coord { x :: Double, y :: Double } deriving <a>Generic</a>
--   
--   instance <a>FromJSON</a> Coord
--   </pre>
--   
--   or using the <a>DerivingVia extension</a>
--   
--   <pre>
--   deriving via <a>Generically</a> Coord instance <a>FromJSON</a> Coord
--   </pre>
--   
--   The default implementation will be equivalent to <tt>parseJSON =
--   <a>genericParseJSON</a> <a>defaultOptions</a></tt>; if you need
--   different options, you can customize the generic decoding by defining:
--   
--   <pre>
--   customOptions = <a>defaultOptions</a>
--                   { <a>fieldLabelModifier</a> = <a>map</a> <a>toUpper</a>
--                   }
--   
--   instance <a>FromJSON</a> Coord where
--       <a>parseJSON</a> = <a>genericParseJSON</a> customOptions
--   </pre>
class () => FromJSON a

-- | A type that can be converted to JSON.
--   
--   Instances in general <i>must</i> specify <a>toJSON</a> and
--   <i>should</i> (but don't need to) specify <a>toEncoding</a>.
--   
--   An example type and instance:
--   
--   <pre>
--   -- Allow ourselves to write <a>Text</a> literals.
--   {-# LANGUAGE OverloadedStrings #-}
--   
--   data Coord = Coord { x :: Double, y :: Double }
--   
--   instance <a>ToJSON</a> Coord where
--     <a>toJSON</a> (Coord x y) = <a>object</a> ["x" <a>.=</a> x, "y" <a>.=</a> y]
--   
--     <a>toEncoding</a> (Coord x y) = <tt>pairs</tt> ("x" <a>.=</a> x <a>&lt;&gt;</a> "y" <a>.=</a> y)
--   </pre>
--   
--   Instead of manually writing your <a>ToJSON</a> instance, there are two
--   options to do it automatically:
--   
--   <ul>
--   <li><a>Data.Aeson.TH</a> provides Template Haskell functions which
--   will derive an instance at compile time. The generated instance is
--   optimized for your type so it will probably be more efficient than the
--   following option.</li>
--   <li>The compiler can provide a default generic implementation for
--   <a>toJSON</a>.</li>
--   </ul>
--   
--   To use the second, simply add a <tt>deriving <a>Generic</a></tt>
--   clause to your datatype and declare a <a>ToJSON</a> instance. If you
--   require nothing other than <a>defaultOptions</a>, it is sufficient to
--   write (and this is the only alternative where the default
--   <a>toJSON</a> implementation is sufficient):
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric #-}
--   
--   import <a>GHC.Generics</a>
--   
--   data Coord = Coord { x :: Double, y :: Double } deriving <a>Generic</a>
--   
--   instance <a>ToJSON</a> Coord where
--       <a>toEncoding</a> = <a>genericToEncoding</a> <a>defaultOptions</a>
--   </pre>
--   
--   or more conveniently using the <a>DerivingVia extension</a>
--   
--   <pre>
--   deriving via <a>Generically</a> Coord instance <a>ToJSON</a> Coord
--   </pre>
--   
--   If on the other hand you wish to customize the generic decoding, you
--   have to implement both methods:
--   
--   <pre>
--   customOptions = <a>defaultOptions</a>
--                   { <a>fieldLabelModifier</a> = <a>map</a> <a>toUpper</a>
--                   }
--   
--   instance <a>ToJSON</a> Coord where
--       <a>toJSON</a>     = <a>genericToJSON</a> customOptions
--       <a>toEncoding</a> = <a>genericToEncoding</a> customOptions
--   </pre>
--   
--   Previous versions of this library only had the <a>toJSON</a> method.
--   Adding <a>toEncoding</a> had two reasons:
--   
--   <ol>
--   <li><a>toEncoding</a> is more efficient for the common case that the
--   output of <a>toJSON</a> is directly serialized to a
--   <tt>ByteString</tt>. Further, expressing either method in terms of the
--   other would be non-optimal.</li>
--   <li>The choice of defaults allows a smooth transition for existing
--   users: Existing instances that do not define <a>toEncoding</a> still
--   compile and have the correct semantics. This is ensured by making the
--   default implementation of <a>toEncoding</a> use <a>toJSON</a>. This
--   produces correct results, but since it performs an intermediate
--   conversion to a <a>Value</a>, it will be less efficient than directly
--   emitting an <a>Encoding</a>. (this also means that specifying nothing
--   more than <tt>instance ToJSON Coord</tt> would be sufficient as a
--   generically decoding instance, but there probably exists no good
--   reason to not specify <a>toEncoding</a> in new instances.)</li>
--   </ol>
class () => ToJSON a

-- | Decode Special Characters.
--   
--   Where:
--   
--   <pre>
--   Data.Text.Lazy.Encoding.decodeLatin1 :: ByteString -&gt; Text
--   Data.Text.Lazy.Encoding.encodeUtf8 :: Text -&gt; ByteString
--   Data.Aeson.eitherDecode :: ByteString -&gt; Either String a
--   </pre>
--   
--   This will successfully decode a ByteString containing special
--   characters such as <tt>°</tt> (ASCII decimal 176).
eitherDecodeSpecial :: FromJSON a => ByteString -> Either String a

-- | Encode Special Characters.
--   
--   Where:
--   
--   <pre>
--   Data.Aeson.Text.encodeToLazyText :: ToJSON a =&gt; a -&gt; Text
--   Data.Text.Lazy.Encoding.encodeUtf8 :: Text -&gt; ByteString
--   </pre>
encodeSpecial :: ToJSON a => a -> ByteString
instance GHC.Generics.Generic MyJson.MyJson
instance GHC.Show.Show MyJson.MyJson
instance GHC.Classes.Eq MyJson.MyJson
instance Data.Aeson.Types.FromJSON.FromJSON MyJson.MyJson
instance Data.Aeson.Types.ToJSON.ToJSON MyJson.MyJson


-- | Get the penultimate of a list.
module MyPenultimate

-- | Get second to last element of a list.
penultimate :: [a] -> Maybe a


-- | Reverse a list using <a>foldl</a> and <a>foldr</a>.
module MyReverse

-- | Reverse a list using <a>foldl</a>.
myRevl :: [a] -> [a]

-- | Reverse a list using <a>foldr</a>. This is the best performing
--   version.
--   
--   This pointfree form is the same as:
--   
--   <pre>
--   myRevr xs = foldr (\ x acc -&gt; (x :) &gt;&gt;&gt; acc) id xs []
--   </pre>
myRevr :: [a] -> [a]

-- | Reverse using recursion and reverse operation.
myRevRec :: [a] -> [a]


-- | A simple State monad implementation to explore it's characteristics.
--   
--   Based on many articles, but principally from: <a>The State Monad: A
--   Tutorial for the Confused?</a>
module MyState

-- | Mock of MyState data type. (Not yet a Monad, Functor or Applicative.)
newtype MyState s a
MyState :: (s -> (a, s)) -> MyState s a
[runState] :: MyState s a -> s -> (a, s)

-- | Returns current state.
get :: MyState s s

-- | Replace current state with the given value. Returns unit.
put :: s -> MyState s ()

-- | Update current state using the given function.
modify :: (s -> s) -> MyState s ()

-- | Returns results of state function.
evalState :: MyState s a -> s -> a

-- | Returns final state.
execState :: MyState s a -> s -> s
instance GHC.Base.Functor (MyState.MyState s)
instance GHC.Base.Applicative (MyState.MyState s)
instance GHC.Base.Monad (MyState.MyState s)


module MyTake

-- | My version of take. This does not check for negative numbers.
--   
--   <pre>
--   &gt;&gt;&gt; myTake 1 "abc"
--   "a"
--   </pre>
myTake :: Int -> [a] -> [a]


module MyType

-- | Proxy to record type. Proxy is equivalent to the unit type,
--   <tt>()</tt>. But also has a phantom type parameter <tt>a</tt>, which
--   is used to keep track of the type. (Use type from <a>Proxy</a>) data
--   Proxy a = Proxy
--   
--   Show ambigous types. Hindley-Milner type system can only infer types
--   to the right of the context arrow (<tt>=&gt;</tt>), which means the
--   type parameter <tt>a</tt> can never be correctly inferred. Haskell
--   refers to such a type as <i>ambiguous</i>.
--   
--   <pre>
--   &gt;&gt;&gt; typeName @Int
--   "Int"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; typeName @String
--   "[Char]"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; typeName @(Maybe [Int])
--   "Maybe [Int]"
--   </pre>
typeName :: forall a. Typeable a => String


-- | From the book <a>Algorithm Design with Haskell by R. Bird and J.
--   Gibbons</a>.
module Permutation

-- | Insert character into list at each location.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; inserts 'a' "bc"
--   ["abc","bac","bca"]
--   </pre>
inserts :: a -> [a] -> [[a]]

-- | Generate permutations using list comprehensions.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; perms1 "abc"
--   ["abc","bac","bca","acb","cab","cba"]
--   </pre>
perms1 :: [a] -> [[a]]

-- | Generate permutations using list comprehensions.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; perms2 "abc"
--   ["abc","acb","bac","bca","cab","cba"]
--   </pre>
perms2 :: [a] -> [[a]]

-- | Use fold to generate permutaions.
perms3 :: [a] -> [[a]]

-- | Pick each member from list return tuple of member and items remaining.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; picks "abc"
--   [('a',"bc"),('b',"ac"),('c',"ab")]
--   </pre>
picks :: [a] -> [(a, [a])]


-- | Find poly-divisible numbers such that we use digits from 1 to 9, and
--   the first n digits are modulo n for all digits in the number.
--   
--   I first read about puzzle in Matt Parkers book, <a>Things to make and
--   do in the fourth dimension</a>.
--   
--   The poly divisors listed here are in descending order of performance.
--   i.e. <tt>isPolyMod</tt> better than <tt>isPolyMod'</tt> which is
--   better than <tt>isPolyMod''</tt>
--   
--   <h2>Method</h2>
--   
--   <ul>
--   <li>convert string input to int</li>
--   <li>permute a list of digits 1..9</li>
--   <li>filter modulo (length) for length digits</li>
--   </ul>
--   
--   <h2>Exploration</h2>
--   
--   Investigate how to use a fold instead of recursion:
--   
--   <pre>
--   &gt;&gt;&gt; x = 123456789
--   
--   &gt;&gt;&gt; n = length (show x)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; λ&gt; map (\p -&gt; x `div` 10^p ) [0..n-1]
--   [123456789,12345678,1234567,123456,12345,1234,123,12,1]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; λ&gt; f x = let n = length (show x) in x `mod` n == 0
--   
--   &gt;&gt;&gt; λ&gt; f 12
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; λ&gt; foldr (\x -&gt; (&amp;&amp;) (f x)) True xs
--   False
--   </pre>
--   
--   <h2>Examples</h2>
--   
--   Load in GHCi:
--   
--   <pre>
--   &gt;&gt;&gt; $ cabal repl
--   
--   &gt;&gt;&gt; λ&gt; :load PolyDivisors
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; λ&gt; findPolyDiv 123
--   [123,321]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; λ&gt; findPolyDiv 123456
--   [123654,321654]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; λ&gt; findPolyDiv 123456789
--   [381654729]
--   </pre>
module PolyDivisors

-- | Find poly-divisor of input string.
findPolyDiv :: Int -> [Int]

-- | <a>isPolyMod</a>: Test number is modulo <tt>n ... 1</tt>.
isPolyMod :: Int -> Bool

-- | <tt>isPolyMod''</tt>: Test number is modulo <tt>n ... 1</tt>.
isPolyMod' :: Int -> Bool

-- | <tt>isPolyMod''</tt>: Test number is modulo <tt>n ... 1</tt>.
isPolyMod'' :: Int -> Bool


-- | A simple implementation of <a>Qsort</a>.
--   
--   From "Programming in Haskell" by Graham Hutton.
--   
--   <pre>
--   &gt;&gt;&gt; qsort [3,5,1,2,4,2]
--   [1,2,2,3,4,5]
--   </pre>
--   
--   If <tt>a &lt;= x</tt> is replaced with <tt>a &lt; x</tt>, then only
--   unique values are reported.
--   
--   <pre>
--   &gt;&gt;&gt; qsort' [3,5,1,2,4,2]
--   [1,2,3,4,5]
--   </pre>
--   
--   To reverse sort, switch smaller and larger in <a>qsort</a>.
--   
--   <pre>
--   &gt;&gt;&gt; qsort'' [3,5,1,2,4,2]
--   [5,4,3,2,2,1]
--   </pre>
module Qsort

-- | A simple implementation of <a>Qsort</a>.
qsort :: (Show a, Ord a) => [a] -> [a]


-- | Exploration of the use of <a>Random</a> inspired by <a>Haskell Design
--   Patterns by Ryan Lemmer</a>
--   
--   <h2>Example</h2>
--   
--   Simulate roll a fair 6-sided dice <i>n</i> times.
--   
--   With a <a>seed</a> of <tt>111111</tt> then we expect
--   <tt>[4,6,5,3,2]</tt>.
module Random

-- | Range for a 6-sided dice.
dice :: (Int, Int)

-- | Return <i>n</i> rolls of the dice using the system random generator.
roll :: Int -> IO [Int]

-- | Produce an infinite stream of <a>dice</a> rolls.
rolls :: StdGen -> [Int]

-- | Seed the dice's random generator.
seed :: Int -> StdGen


-- | A collection of recursion scheme examples.
--   
--   <h1>Examples</h1>
--   
--   <h2>Anamorphism</h2>
--   
--   Using a non-recursive coalgebra to create a <a>ListF</a>.
--   
--   <pre>
--   test = buildListF 4
--   show test
--   "ConsF 4 (ConsF 3 (ConsF 2 (ConsF 1 NilF)))"
--   
--   λ&gt; :t unFix test
--   unFix test :: ListF Int (Fix (ListF Int))
--   
--   λ&gt; :t test
--   test :: Fix (ListF Int)
--   </pre>
--   
--   <h2>Catamorphism</h2>
--   
--   Using a non-recursive algebra to measure length of <a>ListF</a> entry,
--   use a catamorphism over the alegra to measure length of the entire
--   <a>ListF</a>.
--   
--   <pre>
--   test :: Int a =&gt; Fix (ListF a)
--   test = Fix (ConsF 4 (Fix (ConsF 3 (Fix (ConsF 2 (Fix (ConsF 1 (Fix NilF))))))))
--   
--   lengthListF test
--   4
--   </pre>
--   
--   <h2>Paramorphism</h2>
--   
--   The paramorphism examples come from "Making Sense of Recursion
--   Patterns". A paramorphism is like a catamorphism, but it preserves the
--   initial data structure.
--   
--   <h1>References</h1>
--   
--   <ul>
--   <li><a>Deriving a functor for an infinite stream</a></li>
--   <li><a>Making Sense of Recursion Patterns by Paul Bailes and Leighton
--   Brough</a></li>
--   </ul>
module RecursionSchemes

-- | Generalised fixed point for any functor <i>f</i>. Note that <tt>unFix
--   (Fix x) == x</tt>
newtype Fix f
Fix :: f (Fix f) -> Fix f
[unFix] :: Fix f -> f (Fix f)

-- | List Functor where r is the carrier type.
data ListF a r
NilF :: ListF a r
ConsF :: a -> r -> ListF a r

-- | Natural numbers Functor.
data NatF r
ZeroF :: NatF r
SuccF :: r -> NatF r

-- | Natural numbers type.
type Nat = Fix NatF

-- | The code defines a type synonym RAlgebra that represents a recursive
--   algebra for a functor f. An R-algebra is a function that takes a fixed
--   point of a functor Fix f and a value of type f a, and returns a value
--   of type a.
--   
--   The Fix type is used to define recursive data structures in Haskell.
--   It is a type constructor that takes a functor f as an argument and
--   returns a fixed point of f. The Fix type is used to define recursive
--   data structures by wrapping a value of type f (Fix f) in a Fix
--   constructor.
--   
--   The RAlgebra type synonym is used to define a function that takes a
--   fixed point of a functor Fix f and a value of type f a, and returns a
--   value of type a. This function is used to define recursive functions
--   that operate on data structures defined using Fix.
--   
--   The RAlgebra type synonym is a higher-order type that takes two type
--   arguments: f, which is a functor, and a, which is the return type of
--   the algebra. The RAlgebra type synonym is used to define recursive
--   functions that operate on data structures defined using Fix.
type RAlgebra f a = Fix f -> f a -> a

-- | Anamorphism - produce a structure.
ana :: Functor f => (a -> f a) -> a -> Fix f

-- | Catamorphism - consume a structure.
cata :: Functor f => (f a -> a) -> Fix f -> a

-- | Paramorphism - improved consumption of a structure.
para :: Functor f => RAlgebra f a -> Fix f -> a

-- | Paramorphism where input list is the first parameter. This comes from
--   <a>Making Sense of Recursion Patterns</a> by Paul Bailes and Leighton
--   Brough. It extends <a>foldr</a> by supplying to the combining
--   operation (op) the unprocessed list tail, in addition to the head and
--   the result of recursion on the tail as provided by <a>foldr</a>.
--   
--   Sum a list:
--   
--   <pre>
--   &gt;&gt;&gt; para' (const . (+)) 0 [1,2,3]
--   6
--   </pre>
--   
--   Suffixes of a list:
--   
--   <pre>
--   &gt;&gt;&gt; para' (const (:)) [] "abcd"
--   ["bcd","cd","d",""]
--   </pre>
para' :: (a -> [a] -> b -> b) -> b -> [a] -> b

-- | Paramorphism using <a>foldr</a>. This comes from <a>Making Sense of
--   Recursion Patterns</a> by Paul Bailes and Leighton Brough.
--   
--   The following shows how to get a catamorphism from a paramorphism. In
--   this example, we are calculating the sum of items from a list.
--   
--   Sum a list:
--   
--   <pre>
--   &gt;&gt;&gt; para'' (const . (+)) 0 [1,2,3]
--   6
--   </pre>
--   
--   Suffixes of a list:
--   
--   <pre>
--   &gt;&gt;&gt; para'' (\ _ xs xss -&gt; xs : xss) [] "abcd"
--   ["bcd","cd","d",""]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; para'' (const (:)) [] "abcd"
--   ["bcd","cd","d",""]
--   </pre>
para'' :: (a -> [a] -> b -> b) -> b -> [a] -> b

-- | Feed coalgebra to anamorphism. This will build a list.
--   
--   <pre>
--   &gt;&gt;&gt; buildListF 4 :: Fix (ListF Int)
--   ConsF 4 (ConsF 3 (ConsF 2 (ConsF 1 NilF)))
--   </pre>
buildListF :: Int -> Fix (ListF Int)

-- | Coalgebra is a non-recursive function to generate a <a>ListF</a>
--   entry.
buildCoalg :: Int -> ListF Int Int

-- | An alegbra over <a>ListF</a> to get list length.
lengthAlg :: ListF a Int -> Int

-- | Length is a folding operation, i.e. a Catamorphism.
--   
--   <pre>
--   &gt;&gt;&gt; (lengthListF . buildListF) 4
--   4
--   </pre>
lengthListF :: Fix (ListF a) -> Int

-- | Length using special case of paramorphism.
--   
--   <pre>
--   &gt;&gt;&gt; lengthListF' (buildListF 4)
--   4
--   </pre>
lengthListF' :: Fix (ListF a) -> Int

-- | Convert Natural number to an integer.
--   
--   <pre>
--   &gt;&gt;&gt; fromNat (toNat 4)
--   4
--   </pre>
fromNat :: Nat -> Int

-- | Build a natural number from an interger.
--   
--   <pre>
--   &gt;&gt;&gt; toNat 4
--   SuccF (SuccF (SuccF (SuccF ZeroF)))
--   </pre>
toNat :: Int -> Nat

-- | Insert element into list at correct ordered position using
--   <a>foldr</a>.
--   
--   <pre>
--   &gt;&gt;&gt; insert 1 [2,3,4]
--   [1,2,3,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; insert 'c' "abde"
--   "abcde"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; insert 'f' "abcde"
--   "abcdef"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; insert 'o' "oa"
--   "ooa"
--   </pre>
insert :: Ord a => a -> [a] -> [a]

-- | Insert element into list at correct ordered position.
--   
--   <pre>
--   &gt;&gt;&gt; insert' 1 [2,3,4]
--   [1,2,3,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; insert' 1 []
--   [1]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; insert' 'c' "abde"
--   "abcde"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; insert' 'c' "abde" == "abcde"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; insert' 'o' "oa"
--   "ooa"
--   </pre>
insert' :: Ord a => a -> [a] -> [a]

-- | Convert a <a>ListF</a> to a standard list.
toList :: Fix (ListF a) -> [a]

-- | Indexing a list.
--   
--   <pre>
--   &gt;&gt;&gt; idx0 "abcde"
--   [0,1,2,3,4]
--   </pre>
idx0 :: (Foldable t, Num b) => t a -> [b]

-- | Alternate list indexing using <a>foldr</a>.
--   
--   <pre>
--   &gt;&gt;&gt; idx1 "abcde"
--   [0,1,2,3,4]
--   </pre>
idx1 :: (Foldable t, Num b) => t a -> [b]

-- | Alternate list indexing using <a>zipWith</a>.
--   
--   <pre>
--   &gt;&gt;&gt; idx2 "abcde"
--   [0,1,2,3,4]
--   </pre>
idx2 :: [b] -> [Integer]

-- | List indexing using <a>foldr</a>.
--   
--   <pre>
--   &gt;&gt;&gt; idx3 "abcde"
--   [0,1,2,3,4]
--   </pre>
idx3 :: Foldable t => t a -> [Integer]

-- | List indexing using <a>foldr</a> with parameter last.
--   
--   <pre>
--   &gt;&gt;&gt; idx4 "abcde"
--   [0,1,2,3,4]
--   </pre>
idx4 :: [b] -> [Integer]
instance (GHC.Classes.Eq a, GHC.Classes.Eq r) => GHC.Classes.Eq (RecursionSchemes.ListF a r)
instance (GHC.Show.Show a, GHC.Show.Show r) => GHC.Show.Show (RecursionSchemes.ListF a r)
instance GHC.Base.Functor (RecursionSchemes.ListF a)
instance GHC.Base.Functor RecursionSchemes.NatF
instance GHC.Show.Show r => GHC.Show.Show (RecursionSchemes.NatF r)
instance GHC.Show.Show (f (RecursionSchemes.Fix f)) => GHC.Show.Show (RecursionSchemes.Fix f)
instance GHC.Classes.Eq (f (RecursionSchemes.Fix f)) => GHC.Classes.Eq (RecursionSchemes.Fix f)


-- | From <a>Time Traveling In Haskell: How It Works And How To Use It</a>
--   by Daniel Lafe.
--   
--   Code for what Csongor calls the repMax problem:
--   
--   <pre>
--   Imagine you had a list, and you wanted to replace all the elements of
--   the list with the largest element, by only passing the list once.
--   </pre>
--   
--   How can we possibly do this in one pass? First, we need to find the
--   maximum element, and only then can we have something to replace the
--   other numbers with! It turns out, though, that we can just expect to
--   have the future value, and all will be well.
--   
--   In the function <a>repMax</a> takes the list of integers, each of
--   which it must replace with their maximum element. It also takes as an
--   argument the maximum element, as if it had already been computed. It
--   does, however, still compute the intermediate maximum element, in the
--   form of <tt>m'</tt>. Otherwise, where would the future value even come
--   from?
--   
--   Thus far, nothing too magical has happened. It’s a little strange to
--   expect the result of the computation to be given to us; it just looks
--   like wishful thinking. The real magic happens in Csongor’s
--   <a>doRepMax</a> function.
--   
--   Look, in particular, on the line with the <tt>where</tt> clause. We
--   see that <a>repMax</a> returns the maximum element of the list,
--   largest, and the resulting list <tt>xs'</tt> consisting only of
--   <i>largest</i> repeated as many times as <tt>xs</tt> had elements. But
--   what’s curious is the call to <a>repMax</a> itself. It takes as input
--   <tt>xs</tt>, the list we’re supposed to process and largest, the value
--   that <i>it itself returns</i>.
--   
--   See also <a>Time travel in Haskell for dummies</a> by Csongor Kiss.
--   
--   See <a>this</a> for an explanation on how <a>mapAccumR</a> works.
--   
--   <h2>Example</h2>
--   
--   Run <a>doRepMax</a> or <a>foldMax</a> over some lists:
--   
--   <pre>
--   &gt;&gt;&gt; doRepMax [2,3,1,4,5]
--   [5,5,5,5,5]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; doRepMax [-2,-3,-1,-4,-5]
--   [-1,-1,-1,-1,-1]
--   </pre>
module RepMax

-- | Replace list with maximum value in the list.
doRepMax :: Integral a => [a] -> [a]

-- | Fold version of <a>repMax</a>.
--   
--   Modified to also work with negative values. <i>"Everything's a
--   fold".</i>
foldMax :: Integral a => [a] -> [a]

-- | Repeat given maximum for entire list.
repMax :: Integral a => [a] -> a -> (a, [a])

-- | Generalise <a>repMax</a> where input is a <tt>Traversable</tt>.
--   
--   Seed value from <tt>First</tt> of <tt>Foldable</tt>.
traverseMax :: (Traversable t, Integral a) => t a -> t a

-- | Generalise <a>repMax</a> where input is a <tt>Traversable</tt>.
--   
--   Seed maximum value from head of list or 0 if empty.
traverseMax' :: (Traversable t, Integral a) => t a -> t a


-- | Split a list in half using <a>zipWith</a>.
--   
--   From <a>My favorite Haskell function by David Luposchainsky</a>
module SplitList

-- | Drop every second element.
every2nd :: [a] -> [a]

-- | Ignore count of first elements then print overflow from second.
zipOverflow :: [a] -> [a] -> [a]

-- | Split list into two.
splitMiddle :: [a] -> ([a], [a])


-- | Use the <a>MyState</a> monad to implement a <a>Stack</a>.
--   
--   Source: <a>sdiehl/state.hs</a>
module Stack

-- | Stack as array of intergers.
type Stack = [Int]

-- | Empty stack.
empty :: Stack

-- | Remove element from top of stack.
pop :: MyState Stack Int

-- | Push element onto stack.
push :: Int -> MyState Stack ()

-- | Return element at top of stack.
top :: MyState Stack Int

-- | Example usage of <a>MyState</a> <a>Stack</a>. <a>push</a> &amp;
--   <a>pop</a> some elements onto the stack, and read the current
--   <a>top</a> element.
tasks :: MyState Stack Int


-- | This is a collection of different ways (with different performance) to
--   create <a>subsquences</a>.
--   
--   <h1>Examples</h1>
--   
--   <pre>
--   subSeqs1 "abc" should be ["a","ab","abc","ac","b","bc","c"]
--   subSeqs2 "abc" should be ["a","ab","abc","ac","b","bc","c"]
--   subSeqs3 "abc" should be ["abc","ab","ac","a","bc","b","c",""]
--   subSeqs4 "abc" should be ["abc","ab","ac","a","bc","b","c",""]
--   </pre>
module SubSeqs

-- | From Pearls of Functional Algorithm Design.
subSeqs1 :: [a] -> [[a]]

-- | Alternative definition using just <a>foldr</a> and <a>map</a>. For
--   non-empty lists only.
subSeqs2 :: [a] -> [[a]]

-- | Using list comprehension.
subSeqs3 :: [a] -> [[a]]

-- | Create a power-set using <a>Monad</a>.
--   
--   <a>This blog</a> explains <a>filterM</a>.
subSeqs4 :: [a] -> [[a]]


-- | An inefficient alternative to <a>dropWhile</a>.
--   
--   <h1>Examples</h1>
--   
--   <pre>
--   &gt;&gt;&gt; trim " hello world "
--   "hello world"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; dropWhile' isSpace " hello world "
--   "hello word "
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; dropWhileEnd' isSpace " hello world "
--   " hello word"
--   </pre>
module Trim

-- | Drop from beginning of list while predicate is true.
dropWhile' :: (a -> Bool) -> [a] -> [a]

-- | Drop from end of list while predicate is true.
dropWhileEnd' :: (a -> Bool) -> [a] -> [a]

-- | Trim white space from start of string.
trimStart :: String -> String

-- | Trim white space from end of string.
trimEnd :: String -> String

-- | Trim white space from start and end of string.
trim :: String -> String


-- | A simple demonstration on how to map to and from a bounded, enumerated
--   data type.
--   
--   In this example we use the weekdays names as our type to iterate
--   across.
--   
--   <ul>
--   <li><a>makeWeekday</a> is a simple conversion function to map a
--   <a>Weekday</a> from a string</li>
--   <li><a>fullWeek</a> returns a list of all abbreviated weekdays</li>
--   <li><a>capitalise</a> returns the title case of a string</li>
--   </ul>
--   
--   The <a>makeWeekday</a> code is rather weak as any word where the first
--   3 letters map to a weekday is valid for conversion.
--   
--   <h2>Other Examples</h2>
--   
--   <h3>Using enum:</h3>
--   
--   This example shows how use <a>Weekday</a> from an enumeration:
--   
--   <pre>
--   &gt;&gt;&gt; toEnum 0 :: WeekDay
--   Mon
--   </pre>
module Weekday

-- | Abbreviated days of the week from Mon (Monday) to Sun (Sunday).
data Weekday
Mon :: Weekday
Tue :: Weekday
Wed :: Weekday
Thu :: Weekday
Fri :: Weekday
Sat :: Weekday
Sun :: Weekday

-- | Read a <a>Weekday</a> from a String.
--   
--   Some string to <a>Weekday</a> examples:
--   
--   <pre>
--   &gt;&gt;&gt; makeWeekday "tHU"
--   Just Thu
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; makeWeekday "sun"
--   Just Sun
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; makeWeekday "Bad"
--   Nothing
--   </pre>
--   
--   Any string bigger than 3 characters also fails: &gt;&gt;&gt;
--   makeWeekday <a>Mond</a> Nothing
makeWeekday :: String -> Maybe Weekday

-- | List all days of the week.
--   
--   <pre>
--   &gt;&gt;&gt; fullWeek
--   [Mon,Tue,Wed,Thu,Fri,Sat,Sun]
--   </pre>
fullWeek :: [Weekday]

-- | Return title case of string.
--   
--   <pre>
--   &gt;&gt;&gt; capitalise "monday"
--   "Monday"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; null (capitalise "")
--   True
--   </pre>
capitalise :: String -> String
instance GHC.Read.Read Weekday.Weekday
instance GHC.Enum.Bounded Weekday.Weekday
instance GHC.Show.Show Weekday.Weekday
instance GHC.Enum.Enum Weekday.Weekday
instance GHC.Classes.Eq Weekday.Weekday
instance Test.QuickCheck.Arbitrary.Arbitrary Weekday.Weekday


-- | Yahtzee test suite from blog <a>Good Design and Type Safety in
--   Yahtzee</a>
module Yahtzee

-- | Keep the dice, or re-roll?
data DiceChoice
Keep :: Word -> DiceChoice
Reroll :: DiceChoice

-- | Dice values from 1 to 6.
type DiceVals = [Word]

-- | Generate all rolls from a given state.
allRolls :: [DiceChoice] -> [DiceVals]


-- | From <a>Zipping with Folds</a> which is based on <a>How to Zip with
--   Folds</a>.
--   
--   The <tt>Prelude</tt>s version of <a>zip</a> uses recursion:
--   
--   <pre>
--   zip :: [a] -&gt; [b] -&gt; [(a,b)]
--   zip []     _bs    = []
--   zip _as    []     = []
--   zip (a:as) (b:bs) = (a,b) : zip as bs
--   </pre>
--   
--   But, this won't work for streams. The version included below
--   <i>does</i> work with streams. It uses a recursive type to represent
--   the stream data. This matches from the beginning of the stream. You
--   could match from the end of the stream by swapping <a>foldr</a> with
--   <a>foldl</a>.
module ZipFold

-- | Defines a recursive type.
newtype Zip a b
Zip :: (a -> (Zip a b -> b) -> b) -> Zip a b
[runZip] :: Zip a b -> a -> (Zip a b -> b) -> b

-- | Function to fuse two folds.
zip :: [a] -> [b] -> [(a, b)]

-- | Zip from fold.
--   
--   <pre>
--   &gt;&gt;&gt; zip' [1,2,3] [4,5,6]
--   [(1,4),(2,5),(3,6)]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; zip' "abc" []
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; zip' [] "abc"
--   []
--   </pre>
zip' :: [a] -> [b] -> [(a, b)]
